function [ perf, perf_maps, mass, tags ] = VolumePerfusion_beta( acq_path, mask_org_path, params )
% [ perf, perf_maps, mass ] = VolumePerfusion( acq_path, mask_org_path, params )
%VOLUMEPERFUSION is a generalized function used to calculate volumetric
%perfusion.
%
%   VolumePerfusion is a generalized function that can be used calculate
%   organ-specific perfusion.  Required function parameters are included as
%   basic function inputs, while optional parameters may be specificied by
%   inputting the params(struct) variable.  For reference,
%   the first line of variable descriptions, below, will first include the
%   variable type and an example of a real definition of the variable.  If
%   the variable is a type that cannot be represented in a text (like a
%   matrix), a detail, such as the variables dimensions, may be included 
%   instead.  Functionality is included to streamline the processing of
%   perfusion measurements into Excel sheets, as well as processing
%   regional perfusion measurements.  All prefusion measurements are
%   performed on a volumetric basis, and rely primarily on only 2 volumes.
%   Further, functionality has been implemented to provide 'intelligent'
%   selection to differentiate prospective and retrospective acquisitions.
% 
%   TESTING
%       CARDIAC | COMPLETE
%       BRAIN   | COMPLETE
%       LUNG    | COMPLETE
%       KIDNEY  | COMPLETE
%
%       ERROR HANDLING | COMPLETE
%       WARNINGS       | COMPLETE
% 
%   INPUTS:
%
%   acq_path                      STR | '//polaris.../05_13_15_data/ACQ1'
%                                 Complete path to acquisition of interest.
%                                 Include 'REGISTERED' if necessary, it
%                                 will not be automatically appended.
%                                 *REQUIRED*
% 
%   mask_org_path                 STR | 'SEGMENT_HEART/HEART_BW.mat'
%                                 Complete path or folder path (relative to
%                                 acq_path) to segmentation volume of the
%                                 whole organ of interest.
%                                 *REQUIRED*
%
%
%   params...                     STRUCT
%                                 *OPTIONAL*
% 
%       verbose                   LOGICAL | false [DEFAULT VALUE]
%                                 Setting verbose to true will allow
%                                 warnings specific to perfusion to be
%                                 displayed.  These optional warnings
%                                 display the triggering scheme
%                                 (PROSPECTIVE/RETROSPECTIVE) used.
% 
%       aif_path                  STR | [acq_path '/Asc_Ao_autoGenerated.mat'] [DEFAULT VALUE]
%                                 Path to arterial input function OR
%                                 arterial input function mask volume.  If
%                                 the arterial input function path is
%                                 provided, it simply be loaded and used.
%                                 If the arterial input function mask path
%                                 is provided, the arterial input function
%                                 will be calculated and saved
%                                 automatically.
% 
%       time_vec_path             STR | [acq_path '/time_vec_autoGenerated.mat'] [DEFAULT VALUE]
%                                 Path to time vector to use.
% 
%       xlsx_path                 STR | '//polaris.../05_13_15_data/perf_data.xlsx'
%                                 Path to excel file to save perfusion
%                                 data.  Data will 'intelligently' be
%                                 appended to the provided file path.  If
%                                 excel_path is not defined by the user, NO
%                                 DATA will be saved.
% 
%       mask_reg_path             STR | '//polaris.../05_13_15_data/17_seg/HEART_LV.mat'
%                                 Complete path to ordinal mask of regions
%                                 to calculate perfusion within.  Data of
%                                 each region will be 'intelligently'
%                                 outputted into xlsx_path.
% 
%       mask_reg_labels           {STR} | {'AHA17', 'SEG1', 'SEG2',... 'SEG17'} 
%                                 Vector-string to use as labels for
%                                 corresponding regions in mask_reg_path.
%                                 The first element of label_reg_path
%                                 will denote the sheetname in xlsx_path,
%                                 where regional perfusion data will be
%                                 outputted to.  The rest of the elements
%                                 will positionally-correspond to the
%                                 respectively numbered region ibn
%                                 mask_reg_path.  Thus, the region labeled
%                                 '1' in mask_reg_path will correspond to
%                                 'SEG1', based off the provided example.
%                                 label_reg_path is not required, even if
%                                 mask_reg_path is defined.  If
%                                 label_reg_path is not defined, a generic
%                                 naming convention will be applied, but
%                                 regional perfusion calculations will
%                                 still be performed.
% 
%       tissue_rho                DOUBLE | 1.035 g/mL [DEFAULT VALUE]
%                                 For organs where tissue denisty is
%                                 largely homogeneous, tissue_rho will
%                                 define the tissue density in g/mL.
%                                 Future iterations of this function, where
%                                 tissue is heterogeneous (like lung/brain)
%                                 relevant processing differences will need
%                                 to be addressed.
% 
%       v1_trigger_hu             DOUBLE | 300 HU [DEFAULT VALUE]
%                                 For retrospective acquisitions,
%                                 v1_trigger_hu will be the threshold, in HU, 
%                                 that will be used to determine when to 
%                                 select volume 1, for perfusion
%                                 calculations.  The true HU threshold used
%                                 to trigger V1 is calculated as the
%                                 average of the first 3 values in the AIF
%                                 PLUS v1_trigger_hu.
% 
%       v1_offset                 INT | 1 [DEFAULT VALUE]
%                                 For retrospective acquisitions, v1_offset
%                                 will be the number of volumes after the
%                                 AIF > v1_trigger_hu
% 
%       v2_trigger_dt             DOUBLE | NaN sec [DEFAULT VALUE]
%                                 For prospective acquisitions,
%                                 v2_trigger_dt will be time-delay, in sec,
%                                 that will be used to determine when to
%                                 select volume 2, for perfusion
%                                 calculations.  If v2_trigger_dt is
%                                 defined as NaN, then the volume at peak
%                                 enhancement will be used to determine
%                                 volume 2.
% 
%       v2_peak_offset            INT | 0 [DEFAULT VALUE]
%                                 Specify the offset of volume 2, when
%                                 performing retrospective (PerfMode:
%                                 RETRO) 2 volume perfusion, from the peak
%                                 of AIF.
% 
%       v2_adj_n                  DOUBLE | 0 [DEFAULT VALUE]
%                                 For prospective acquisitions, v2_adj_n
%                                 will define the number of volumes
%                                 adjacent to volume 2, to be used to
%                                 calculate the input concentration for
%                                 perfusion calculations.  For example, if
%                                 v2_adj_n = 2, after determining
%                                 volume 2 using v2_trigger_dt, two volumes
%                                 before and two volumes after and volume 2
%                                 will all be MIPed together.  This MIP
%                                 volume will be used to calculate the
%                                 input concentration into the organ of
%                                 interest.  Further experimentation should
%                                 be done on this functionality.  MIP may
%                                 not be the best way to implement this
%                                 idea.
%                                 *FUNCTIONALITY NOT IMPLEMENTED YET*
% 
%       register                  LOGICAL | True if 'REGISTERED' acq_path [DEFAULT VALUE]
%                                 Logical parameter to indicate whether to
%                                 register the acquisition of interest.  If
%                                 register is 1, AND the acquisition is NOT
%                                 already registered (i.e. REGISTERED is
%                                 not found in acq_path) then the
%                                 acquisition will be registered.
%                                 *FUNCTIONALITY NOT IMPLEMENTED YET*
% 
%       v1_avg                    DOUBLE | NaN [DEFAULT VALUE]
%                                 If specified, v1_hu_avg will be
%                                 multiplied by volume 2, to determine
%                                 average myocardial perfusion, assuming a
%                                 uniform HU intensity in volume 1; it is a
%                                 quick work-around for cardiac datasets
%                                 that are not able to be adequately
%                                 registered together.
% 
%       aif_vec                   VECTOR(DOUBLE) | Automatically calculated [DEFAULT VALUE]
%                                 An arterial input vector can be manually
%                                 specified, if desired, but aif_vec MUST
%                                 be the same length as the generated
%                                 time_vec; if aif_vec is NOT specified,
%                                 then it is calculated using the
%                                 previously mentioned aif_vec_mask.
% 
%       vol_idx                   VECTOR(INT) | [NaN NaN] [DEFAULT VALUE]
%                                 Specify manually, which indices to use
%                                 for perfusion calculation, respectively.
% 
%       tissue_rho_path           STR | '//polaris/data4new/../MASS_MAP.mat' 
%                                 Path to mass map to use to calculate
%                                 perfusion, where the value of each voxel
%                                 indicates the mass of that voxel, in
%                                 grams.
% 
%       filt_size_mm              SCALAR(DOUBLE) | 0 (mm) [DEFAULT VALUE]
%                                 Use to specify the length of the cube
%                                 kernel to filter perfusion maps of the
%                                 whole organ.  Refer to anatomical
%                                 dimensions (thickness of myocardium or
%                                 average width of brain, for example) to
%                                 help determine an appropriate filter
%                                 size.
%       
%       filt_type                 STR | 'MEDIAN' or 'MEAN'
%                                 By default, no filter is applied.  If
%                                 filtering of the whole organ perfusion
%                                 map is desired, specify either 'MEDIAN'
%                                 or 'MEAN'.  Futher types of filters can
%                                 be implemented in the future.
% 
%       safe_mode                 true or false | [false] [DEFAULT VALUE]
%                                 Specifying 'true' for safe_mode will
%                                 cause VolumePerfusion to run, without
%                                 raising any errors, if an error does
%                                 occur.  The updated text status
%                                 outputted to MATLAB's console will
%                                 indicate 'ERROR' rather than 'COMPLETE',
%                                 if an error does occur during the
%                                 execution of VolumePerfusion, but no
%                                 further description of the error will be
%                                 indicated.  This is ideal for robust
%                                 functionality when processing large
%                                 datasets where errors are not expected.
%                                 Specifying 'false for safe_mode will
%                                 allow errors to be raised normally.
% 
%       aux_aif_path              STR | '' [DEFAULT VALUE]
%                                 Path to arterial input function OR
%                                 arterial input function mask volume.  If
%                                 the arterial input function path is
%                                 provided, it simply be loaded and used.
%                                 If the arterial input function mask path
%                                 is provided, the arterial input function
%                                 will be calculated and saved
%                                 automatically.  Specifically, this
%                                 parameter is used to specify
%                                 VolumePerfusion to use an auxilairy input
%                                 function, to be used to select V1.  In
%                                 cardiac perfusion, we commonly use the
%                                 left atrium AIF to select V1, but we
%                                 still use the aortic AIF to calculate the
%                                 input concentration.
% 
%       aux_aif_delay             DOUBLE | 2.00 sec [DEFAULT VALUE]
%                                 The time offset between then aux_aif
%                                 passes aux_aif_thresh and when V1 index
%                                 is chosen.  Since the Toshiba Aquilione
%                                 ONE has a minimum delay of 2 seconds
%                                 between a SureStart trigger and a full
%                                 volume scan, this parameter can be used
%                                 to recreate the way the scanner will
%                                 actually operate (i.e. the scanner must
%                                 wait at least 2 seconds after aux_aif is
%                                 greater than aux_aif_thresh before
%                                 a full volume scan).
%                                 *THIS PARAMETER IS ONLY APPLIED IF
%                                 AUX_AIF_PATH IS DEFINED*
% 
%       perf_ref_path             STRUCT | EMPTY [DEFAULT VALUE]
%                                 Specify the path to reference standard
%                                 regional perfusion measurements.  Each
%                                 element in this struct should be labeled,
%                                 according to the inputted
%                                 mask_reg_labels, and each elements
%                                 associated value should correspond to
%                                 that region's reference standard
%                                 perfusion measurement (usually from
%                                 microsphere data)
%
%
%   OUTPUTS:
%
%   perf...                       STRUCT
% 
%       whole_organ               DOUBLE | #.## mL/(min * g)
%                                 Calculation of perfusion into
%                                 whole-organ.
% 
%    *REGIONAL PERFUSION MEASUREMENTS*  
% 
%       region1                   DOUBLE | #.## mL/(min *g)
%                                 Calculation of perfusion into region1, as
%                                 defined by mask_reg_path.  If
%                                 mask_reg_path is not provided, regional
%                                 perfusion elements of the variable perf
%                                 will not be defined.
% 
%       region2
%       .
%       .
%       .
%       regionN
%
%
%   perf_maps...                  STRUCT
% 
%       whole_organ               VOLUME(DOUBLE) | 512x512x320 mL/(min * g)
%                                 Volume-map of perfusion in whole organ of
%                                 interest.  No post-processing will be
%                                 provided for any perf_maps.  Further
%                                 processing of perf_maps, such as smoothing
%                                 or writing as DICOM files, should be
%                                 performed OUTSIDE this function.
% 
%    *REGIONAL PERFUSION MAPS*
% 
%       region1                   VOLUME(DOUBLE) | 512x512x320 mL/(min * g)
%                                 Volume-map of perfusion in region of
%                                 interest.  No post-processing will be
%                                 provided for any perf_maps.  Further
%                                 processing of perf_maps, such as smoothing
%                                 or writing as DICOM files, should be
%                                 performed OUTSIDE this function.
% 
%       region2
%       .
%       .
%       .
%       regionN
%
%   AUTHOR:       Shant Malkasian
%   DATE CREATED: 30-Dec-2017
%

TP_info = 'VolumePerfusion | ';
cur_TP = TextProgressbar(TP_info);
% SECTION 0: INITIALIZE
cur_step = 'Initializing variables...';
cur_TP.update(cur_step);

% 0.1: Pre-process acq_path and mask_org_path
acq_path = process_path(acq_path);
mask_org_path = process_path(mask_org_path);

% 0.2: Define default parameters (TODO: Make default parameters same type
% as expected parameter, it makes life easier...)
params_verbose = false;
params_aif_path = [acq_path '/Asc_Ao_autoGenerated.mat'];
params_time_vec_path = [acq_path '/time_vector_autoGenerated.mat'];
params_xlsx_path = false;
params_mask_reg_path = false;
params_mask_reg_labels = false;
params_tissue_rho = 1.053; % g/mL
params_v1_trigger_hu = 140; % HU
params_v1_offset = 1;
params_v2_trigger_dt = NaN; % sec
params_v2_adj_n = 0;
params_v2_peak_offset = 0;
params_aif_vec = [NaN NaN];
params_avg_v1 = [false NaN];
params_register = is_acq_registered(acq_path); % TODO: Integrate registration
params_vol_idx = [NaN NaN];
params_tissue_rho_path = '';
params_safe_mode = false;
params_filt_size_mm = 0;
params_filt_type = '';
params_xlsx_main_path = false;
params_xlsx_add_col = {};
params_aux_aif_vec = [NaN NaN];
params_aux_aif_path = '';
params_aux_aif_delay = 2.00; % SEC
params_perf_ref_path = '';
params_reg_groups = '';
params_delta_time = '';


% 0.3: If user specified optional parameters, overwrite default parameters
if nargin == 3
    usr_vars = fieldnames(params);
    % CHECK THAT USER DEFINED ALLOWABLE PARAMETERS
    check_params_(params, 'params_');
    
    % ADD OPTIONAL PARAMETERS TO DEFINE HERE
    % TODO:  ALPHABETIZE
    if any(strcmp(usr_vars, 'verbose'))
        params_verbose = params.verbose;
    end
    if any(strcmp(usr_vars, 'aif_path'))
        params_aif_path = process_path(params.aif_path);
    end
    if any(strcmp(usr_vars, 'time_vec_path'))
        params_time_vec_path = process_path(params.time_vec_path);
    end
    if any(strcmp(usr_vars, 'xlsx_path'))
        params_xlsx_path = process_path(params.xlsx_path);
    end
    if any(strcmp(usr_vars, 'mask_reg_path'))
        params_mask_reg_path = process_path(params.mask_reg_path);
    end
    if any(strcmp(usr_vars, 'mask_reg_labels'))
        params_mask_reg_labels = params.mask_reg_labels;
    end
    if any(strcmp(usr_vars, 'tissue_rho'))
        params_tissue_rho = params.tissue_rho;
    end
    if any(strcmp(usr_vars, 'v1_trigger_hu'))
        params_v1_trigger_hu = params.v1_trigger_hu;
    end
    if any(strcmp(usr_vars, 'v1_offset'))
        params_v1_offset = params.v1_offset;
    end
    if any(strcmp(usr_vars, 'v2_trigger_dt'))
        params_v2_trigger_dt = params.v2_trigger_dt;
    end
    if any(strcmp(usr_vars, 'v2_adj_n'))
        params_v2_adj_n = params.v2_adj_n;
    end
    if any(strcmp(usr_vars, 'v2_peak_offset'))
        params_v2_peak_offset = params.v2_peak_offset;
    end
    if any(strcmp(usr_vars, 'register'))
        params_register = params.register;
    end
    if any(strcmp(usr_vars, 'aif_vec'))
        params_aif_vec = params.aif_vec;
    end
    if any(strcmp(usr_vars, 'avg_v1'))
        if isnumeric(params.avg_v1) & ~isnan(params.avg_v1) & isscalar(params.avg_v1)
            params_avg_v1 = [true params.avg_v1];
        else
            params_avg_v1 = [params.avg_v1 NaN];
        end 
    end
    if any(strcmp(usr_vars, 'vol_idx'))
        params_vol_idx = params.vol_idx;
    end
    if any(strcmp(usr_vars, 'tissue_rho_path'))
        params_tissue_rho_path = process_path(params.tissue_rho_path);
    end
    if any(strcmp(usr_vars, 'safe_mode'))
        params_safe_mode = params.safe_mode;
    end
    if any(strcmp(usr_vars, 'filt_size_mm'))
        params_filt_size_mm = params.filt_size_mm;
    end
    if any(strcmp(usr_vars, 'filt_type'))
        params_filt_type = params.filt_type;
    end
    if any(strcmp(usr_vars, 'xlsx_main_path'))
        params_xlsx_main_path = params.xlsx_main_path;
    end
    if any(strcmp(usr_vars, 'xlsx_add_col'))
        params_xlsx_add_col = params.xlsx_add_col;
    end
    if any(strcmp(usr_vars, 'aux_aif_vec'))
        params_aux_aif_vec = params.aux_aif_vec;
    end
    if any(strcmp(usr_vars, 'aux_aif_path'))
        params_aux_aif_path = process_path(params.aux_aif_path);
    end
    if any(strcmp(usr_vars, 'aux_aif_delay'))
        params_aux_aif_delay = params.aux_aif_delay;
    end
    if any(strcmp(usr_vars, 'perf_ref_path'))
        params_perf_ref_path = process_path(params.perf_ref_path);
    end
     if any(strcmp(usr_vars, 'delta_time'))
        params_delta_time = params.delta_time;
    end
    
   
end

% try
% 0.4: Enable/Disable status warnings based on user's VERBOSE specification
warning('off', 'MATLAB:xlswrite:AddSheet'); % always disable because its annoying...
if params_verbose
    toggle_warnings_('on');
else
    toggle_warnings_('off');
end

% SECTION 1: LOAD FILES
try
cur_step = 'Loading files...';
cur_TP.update(cur_step);

% % 1.1: Load voxel size
% cur_step = strrep(cur_step, '...', ' | Loading MAT files...');
% cur_TP.update(cur_step);
params_vx_size = get_vx_size([acq_path '/DICOM/']);

% 1.X: (TODO) Register dataset, if specified and dataset is NOT registered
if params_register & ~is_acq_registered(acq_path)
    % Register acqisition here
    molloi_warning('Registration:statusRegistration', 'Registration Status',...
        'Integration of registration functionality has not been implemented yet\n');
end

% 1.2: Loading organ mask binary volume
cur_step = strrep(cur_step, '...', ' | Loading Organ Mask...');
cur_TP.update(cur_step);
mask_org_path = verify_path(acq_path, mask_org_path, 'OrganMask');
organ_mask = load_volume(mask_org_path);
organ_mask = logical(organ_mask);

% 1.3: Loading mass map, if specified
if ~isempty(params_tissue_rho_path)
    cur_step = strrep(cur_step, '...', ' | Loading Mass Map...');
    cur_TP.update(cur_step);
    params_tissue_rho_path = verify_path(acq_path, params_tissue_rho_path, 'MassMap');
    params_tissue_rho = load_volume(params_tissue_rho_path);
end

% 1.4: Make sure all MATs for time-series are generated
cur_step = strrep(cur_step, '...', ' | Checking Time-Series MATs...');
cur_TP.update(cur_step);
gen_mat(acq_path);

% 1.5: Loading AIF or generate AIF if it doesn't exist
% PRIMARY AIF
if any(isnan(params_aif_vec))
    cur_step = strrep(cur_step, '...', ' | Loading Primary AIF...');
    cur_TP.update(cur_step);
    aif_vec = load_aif(params_aif_path, acq_path);
else
    aif_vec = params_aif_vec;
end
% AUX AIF
if any(isnan(params_aux_aif_vec)) && ~isempty(params_aux_aif_path)
    cur_step = strrep(cur_step, '...', ' | Loading Auxiliary AIF...');
    cur_TP.update(cur_step);
    aux_aif_vec = load_aif(params_aux_aif_path, acq_path);
else
    aux_aif_vec = params_aux_aif_vec;
end

% 1.6: Loading time vector, or creating it, if it doesn't exist
cur_step = strrep(cur_step, '...', ' | Loading Time Vector...');
cur_TP.update(cur_step);
time_vec = load_time_vec(params_time_vec_path, acq_path);

% 1.7: Loading reference perfusion measurements, if specified
perf_ref = { };
if ~isempty(params_perf_ref_path)
    cur_step = strrep(cur_step, '...', ' | Loading Reference Measurements...');
    cur_TP.update(cur_step);
    params_perf_ref_path = verify_path(acq_path, params_perf_ref_path, 'Reference');
    perf_ref = load_volume(params_perf_ref_path);
end


catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end


% SECTION 2: DETERMINE v1_idx AND v2_idx
% TODO: MAKE SEPARATE PARAMS_PERF_MODES FOR V1 SELECTION AND V2 SELECTION
% 2.1: Determine V1 and V2 indices

try
cur_step = 'Determining volume indices...';
cur_TP.update(cur_step);

if any(isnan(params_vol_idx))
    [v1_idx, v2_idx, params_perf_mode] = select_vol_idx(aif_vec, time_vec, params_v1_trigger_hu, params_v1_offset, 0, params_v2_trigger_dt);
    if ~any(isnan(aux_aif_vec))
        % AUXILIARY AIF PROVIDED, USE IT TO RECALCULATE V1_IDX
        params_perf_mode = 'RETRO_AUX_AIF';
        params_v1_offset = 0;
        [v1_idx, v2_idx] = select_vol_idx(aux_aif_vec, time_vec, params_v1_trigger_hu, params_v1_offset, params_aux_aif_delay, params_v2_trigger_dt);
    end
end

% 2.2: Determine if user specified manual selection of V1 and V2, and
% overwrite previously calculated V1 and V2
if ~isnan(params_vol_idx(1)) && any(isnan(aux_aif_vec))
    v1_idx = params_vol_idx(1);
    params_perf_mode = 'MANUAL_V1';
end
if ~isnan(params_vol_idx(2))
    v2_idx = params_vol_idx(2);
    params_perf_mode = 'MANUAL_V2';
end
if all(~isnan(params_vol_idx)) && any(isnan(aux_aif_vec))
    params_perf_mode = 'MANUAL';
end

params_v1_thresh_hu = aif_vec(v1_idx);
if ~any(isnan(aux_aif_vec))
    params_v1_thresh_hu = aux_aif_vec(v1_idx - 1);
elseif (any(strfind(params_perf_mode, 'MANUAL')) || any(strfind(params_perf_mode, 'RETRO')))
    if v1_idx == 1
        params_v1_thresh_hu = aif_vec(v1_idx);
    else
        params_v1_thresh_hu = aif_vec(v1_idx - 1);
    end
    
end

if params_v2_adj_n ~= 0
    % EXPERIMENTAL ADDITION HERE
end

%2.3: Add v2 peak offset, if PerfMode is RETRO
if strcmp(params_perf_mode, 'RETRO') || strcmp(params_perf_mode, 'MANUAL_V1')
    if isnan(params_v2_trigger_dt)
        v2_idx = v2_idx + params_v2_peak_offset;
    end
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end

% SECTION 3: CALCULATE INPUT CONCENTRATION AND DELTA TIME
try
cur_step = 'Calculating input concentration...';
cur_TP.update(cur_step);

input_conc = mean([aif_vec(v1_idx) aif_vec(v2_idx)]);

if isempty(params_delta_time)
    delta_time = abs((time_vec(v2_idx) - time_vec(v1_idx)));
else 
    delta_time = params_delta_time;
end


catch ME
    delete(cur_TP, 'ERROR\n');
    if ~params_safe_mode
        throw(ME);
    end
end

% SECTION 4: LOAD V1 AND V2
try
cur_step = 'Loading volumes 1 and 2...';
cur_TP.update(cur_step);

% 4.1: Load volumes
v1_vol = load_volume_idx(acq_path, v1_idx);
v2_vol = load_volume_idx(acq_path, v2_idx);
% 4.2: Distribute uniform HU intensity for V1, if specified
v2_vol(~organ_mask) = 0;
if params_avg_v1(1)
    if ~isnan(params_avg_v1(2))
        v1_vol = double(organ_mask) .* params_avg_v1(2);
    else
        v1_vol = double(organ_mask) .* mean(v1_vol(organ_mask));
    end
else
    v1_vol(~organ_mask) = 0;
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end

% SECTION 5: CALCULATE WHOLE-ORGAN PERFUSION
try
cur_step = 'Calculating perfusion...';
cur_TP.update(cur_step);

% 5.1:  Calculate whole-organ perfusion, perfusion map, mass and change in
% Hounsfield Units (ALWAYS V2 - V1)

[perf.whole_organ, perf_maps.whole_organ, mass.whole_organ, change_hu.whole_organ] = calc_organ_perfusion(v1_vol, v2_vol,...
                                                                                    organ_mask, input_conc, params_tissue_rho,...
                                                                                    params_vx_size, delta_time);
catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end


% SECTION 6: GENERATE TAGS
% Create tags for writing data and error handling (all params_ variables)
try
cur_step = 'Generating output tags...';
cur_TP.update(cur_step);

% 6.1: Define additional parameters to save to Excel (ignore the warning, the variables are
% used)
params_heart_rate = calc_heart_rate(time_vec, params_perf_mode);
params_mask_org_path = mask_org_path;
params_input_conc = input_conc;
params_v1_idx = v1_idx;
params_v2_idx = v2_idx;
%fprintf(acq_path);
[params_study_date, params_acq_label] = gen_study_info(acq_path);
fprintf(params_acq_label);
tags = gen_tags_();

catch ME
    %delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end


% SECTION 7: POST-PROCESSING
% 7.1:  Post process whole-organ perfusion map, if specified
try
cur_step = 'Post-processing perfusion map...';
cur_TP.update(cur_step);

if (params_filt_size_mm > 0) && ~isempty(params_filt_type)
    cur_step = strrep(cur_step,'...', ' | Filtering whole organ perfusion map...');
    cur_TP.update(cur_step);
    filter_map_info = struct;
    filter_map_info.filt_size_mm = params_filt_size_mm;
    filter_map_info.filt_type = params_filt_type;
    filter_map_info.v1_idx = v1_idx;
    filter_map_info.v2_idx = v2_idx;
    filter_map_info.input_conc = input_conc;
    filter_map_info.delta_time = delta_time;
    filter_map_info.acq_path = acq_path;
    filter_map_info.mask_org_path = mask_org_path;
    filter_map_info.vx_size = params_vx_size;
    filter_map_info.ID = tags.ID;
    
    [perf, perf_maps] = filter_organ_perfusion(perf, perf_maps, organ_mask, params_vx_size, params_filt_size_mm, params_filt_type, filter_map_info);
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end


% SECTION 8: CALCULATE REGIONAL PERFUSION
try
cur_step = 'Calculating regional perfusion...';
cur_TP.update(cur_step);

if ischar(params_xlsx_path) && (ischar(params_mask_reg_path) && length(params_mask_reg_labels) > 1)
    params_mask_reg_path = verify_path(acq_path, params_mask_reg_path, 'RegionalMask');
    regional_mask = load_volume(params_mask_reg_path);
    [perf, perf_maps, mass, change_hu] = calc_regional_perfusion(perf, perf_maps, mass, change_hu, v1_vol, v2_vol,...
                                                        organ_mask, regional_mask, params_mask_reg_labels,...
                                                        params_tissue_rho, params_vx_size );
    cur_step = strrep(cur_step, '...', ' | Regional perfusion determined...');
    cur_TP.update(cur_step);
else
    cur_step = strrep(cur_step, '...', ' | Regional perfusion not specified...');
    cur_TP.update(cur_step);
end
 
catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end



% SECTION 9: SAVE DATA TO XLSX FILE
try
cur_step = 'Saving results...';
cur_TP.update(cur_step);

if ischar(params_xlsx_path)
    cur_step = strrep(cur_step, '...', ' | Writing results to Excel file...');
    cur_TP.update(cur_step);
    save_perf_(params_xlsx_path, 'Whole_Organ', tags, 'Whole_Organ', perf.whole_organ, delta_time, mass.whole_organ, change_hu.whole_organ, params_xlsx_add_col);
    save_params_(params_xlsx_path, tags);
    if ischar(params_mask_reg_path) && length(params_mask_reg_labels) > 1
        % LOAD REFERENCE IF PROVIDED
        if ~isempty(perf_ref)
            for i = 2 : length(params_mask_reg_labels)
                if ~isfield(perf, params_mask_reg_labels{i}) || ~any(ismember(perf_ref(:,1), params_mask_reg_labels{i}))
                    continue
                end
                cur_perf = perf.(params_mask_reg_labels{i});
                cur_perf(3) = perf_ref{ismember(perf_ref(:,1), params_mask_reg_labels{i}), 3};
                perf.(params_mask_reg_labels{i}) = cur_perf;
            end
        end
        % WRITE TO EXCEL
        save_perf_regional_(params_xlsx_path, tags, params_mask_reg_labels, perf, delta_time, mass, change_hu, params_xlsx_add_col);
    end
    params_reg_groups = {'SUP', '(ANTSUP)|(POSTSUP)|(SUPERIOR)';...
                         'INF', '(ANTINF)|(POSTINF)|(INFERIOR)'};
    if ischar(params_mask_reg_path) && ~isempty(params_reg_groups)
        if ~isempty(perf_ref)
            for i = 1 : length(params_reg_groups)
                cur_regexp = params_reg_groups{i, 2};
                cur_group = params_reg_groups{i, 1};
                cur_regions = fieldnames(perf);
                cur_group_fields = cur_regions(~cellfun('isempty', regexp(cur_regions, cur_regexp)));
                cur_perf = [0 0 0];
                mean_c = 0;
                for j = 1 : length(cur_group_fields)
                    temp_perf = perf.(cur_group_fields{j});
                    if any(isnan(temp_perf))
                        continue
                    end
                    cur_perf = cur_perf + temp_perf;
                    mean_c = mean_c + 1;
                end
                cur_perf = cur_perf ./ mean_c;
                perf.(cur_group) = cur_perf;
                mass.(cur_group) = 'N/A';
                change_hu.(cur_group) = 'N/A';
            end
            save_perf_regional_(params_xlsx_path, tags, {'GROUP_PLUGS', 'SUP', 'INF'}, perf, delta_time, mass, change_hu, params_xlsx_add_col);
        end
        
    end
end

if ischar(params_xlsx_main_path)
    cur_step = strrep(cur_step, '...', ' | Writing results to main Excel file...');
    cur_TP.update(cur_step);
    save_perf_(params_xlsx_main_path, 'Whole_Organ', tags, 'Whole_Organ', perf.whole_organ, delta_time, mass.whole_organ, change_hu.whole_organ, {});
    save_params_(params_xlsx_main_path, tags);
    if ischar(params_mask_reg_path) && length(params_mask_reg_labels) > 1
        save_perf_regional_(params_xlsx_main_path, tags, params_mask_reg_labels, perf, delta_time, mass, change_hu, {});
    end
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end


% SECTION 10: UPDATE STATUS
% display_prog_(cur_TP, tags, perf.whole_organ, 'COMPLETED');



%% HELPER FUNCTIONS (ALPHABETIZED):
    function [ ] = check_params_(usr_params_, str_prefix_tag_)
        allowable_params = who('-regexp', ['^' str_prefix_tag_]);
        def_usr_vars = fieldnames(usr_params_);
        for i_ = 1 : length(def_usr_vars)
            cur_var = def_usr_vars{i_};
            if ~any(strcmp([str_prefix_tag_ cur_var], allowable_params))
                warning('MolloiWarning:inputParams:parameterNotAllowed',...
                    'MolloiWarning \nInputParams | INPUTTED PARAMETER NOT READ | %s | Please double-check the inputted parameters\n',...
                    cur_var);
            end
        end
    end

    function [ ] = display_prog_(TP_, tags_, perf_, status_)
        str_form = '%s | %s | %s | %13s | %2.2f %s %2.2f mL/min/g | %s\n';
%         sprintf(str_form, tags_.ID, tags_.study_date, tags_.acq_label, tags_.perf_mode, perf_(1), char(177), perf_(2), status_);
%         delete(TP_);

        delete(TP_, sprintf(str_form, tags_.ID, tags_.study_date, tags_.acq_label, tags_.perf_mode, perf_(1), char(177), perf_(2), status_));
    end

    function [organ_mode_] = get_organ_mode_(acq_path_)
        % TRY TO GUESS WHICH ORGAN IS BEING PROCESSED
        % ORIENTATION OF VOLUMES IS DIFFERENT IF ORGAN FROM A
        % CARDIAC(HEART) DATASET
        %
        % POSSIBILITIES:
        %   'HEART'
        %   'LUNG'
        %   'BRAIN'
        %   'KIDNEY'
        
        keyword_map = containers.Map;
        keyword_map('HEART') = {'HEART', 'CARDIAC'};
        keyword_map('LUNG') = {'LUNG', 'PULMONARY'};
        keyword_map('BRAIN') = {'BRAIN', 'CEREBRAL'};
        keyword_map('KIDNEY') = {'KIDNEY', 'RENAL'};
        
        organ_keys = keyword_map.keys;
        organ_mode_ = 'HEART'; % BY DEFAULT...
        for key_ = organ_keys
            for kword_ = keyword_map(key_{1})
                if strfind(lower(acq_path_), lower(kword_{1}))
                    organ_mode_ = key_{1};
                    return
                end
            end
        end
        
    end

    function [tags_] = gen_tags_( )
        % This function creates a struct (tags_) that will be used
        % throughout the function to help save the parameters used.
        % Specifically, all variables whose name starts with 'params_' will
        % be added to tags_.  Additionally, the full file path to this
        % function will be added to tags_.  Finally, (and most
        % importantly) an UNIQUE ID will be created, based of the time the
        % function is ran.  This ID field will be used to save perfusion
        % and parameter data to Excel.  Think of tags_ as a DICOM header.
        cur_datetime = round(clock);
        ID  = sprintf('%04i%02i%02i%02i%02i%02i', cur_datetime(1),... % Year (YYYY)
                                                  cur_datetime(2),... % Month (MM)
                                                  cur_datetime(3),... % Day (DD)
                                                  cur_datetime(4),... % Hour (HH)
                                                  cur_datetime(5),... % Minute (MM)
                                                  cur_datetime(6));   % Second (SS)
        cur_vars = who('-regexp', '^params_');
        tags_.function_name = mfilename('fullpath');
        tags_.ID = ID;
        for var = cur_vars'
            % Add all variables that start with 'params_' to tags_
            t_var = strrep(var, 'params_',''); 
            % IGNORE FOLLOING PARAMS FOR REPORTING
            if any(strcmp(t_var{1}, {'aux_aif_vec', 'aif_vec', 'vol_idx', 'mask_reg_labels', 'xlsx_add_col','reg_groups'}))
                continue
            end
            if size(size(eval(var{1})),2) == 1 ||...
                ischar(eval(var{1})) || isscalar(eval(var{1}))
                tags_.(t_var{1}) = eval(var{1});
            elseif size(eval(var{1}), 3) > 1
                tags_.(t_var{1}) = eval(['mean(' var{1} '(:))']);
            elseif size(eval(var{1}), 2) > 1
                tags_.(t_var{1}) = sprintf('%0.2f ', eval([var{1} '(:)']));
            else
                tags_.(t_var{1}) = 'N/A';
            end 
        end
    end
  
    function [ ] = save_perf_(xlsx_path_, sheet_, tags_, region_, perf_, delta_time_, mass_, delta_hu_, xlsx_add_col_)
        % Save perfusion data to Excel file.  Further outputs can be added
        % through this function.  Be sure to reflect changes in save_perf_
        % in save_perf_regional_!
        if mass_ == 0
            return
        end
        XLSX_struct = struct;
        
        % Enter data into struct
        XLSX_struct.ID              = tags_.ID;
        XLSX_struct.StudyDate       = tags_.study_date;
        XLSX_struct.Acquisition     = tags_.acq_label;
        XLSX_struct.PerfMode        = tags_.perf_mode;
        XLSX_struct.Region          = region_;
        XLSX_struct.Perfusion       = perf_(1);
        XLSX_struct.Perfusion_STD   = perf_(2);
        if length(perf_) == 3
            XLSX_struct.Perfusion_REF = perf_(3);
        end
        XLSX_struct.Flow            = perf_(1) * mass_;
        XLSX_struct.Flow_STD        = perf_(2) * mass_;
        XLSX_struct.DeltaTime       = delta_time_;
        XLSX_struct.Mass            = mass_;
        XLSX_struct.DeltaHU         = delta_hu_;
        XLSX_struct.HeartRate       = tags_.heart_rate;
        if ~isempty(xlsx_add_col_)
            for i_ = 1 : size(xlsx_add_col_, 2)
                cur_add_col = xlsx_add_col_{i_};
                XLSX_struct.(cur_add_col{1}) = cur_add_col{2};
            end
        end
        
        
        % ADD FURTHER OUTPUTS HERE
        
        % Save data to EXCEL
        WriteStructExcel(xlsx_path_, sheet_, XLSX_struct);
    end

    function [ ] = save_perf_regional_(xlsx_path_, tags_, regional_labels_, perf_, delta_time_, mass_, hu_change_, xlsx_add_col_)
        % Save regional perfusion to Excel file
        EXCLUSION_REGIONS = {'IGNORE'};
        for i_ = 2 : length(regional_labels_)
            label = regional_labels_{i_};
            if any(strcmp(label, EXCLUSION_REGIONS))
                continue
            end
            save_perf_(xlsx_path_, regional_labels_{1}, tags_, label, perf_.(label), delta_time_, mass_.(label), hu_change_.(label), xlsx_add_col_);
        end
    end

    function [ ] = save_params_(xlsx_path_, tags_)
        WriteStructExcel(xlsx_path_, 'PARAMS', tags_);
    end
    
    function [ ] = toggle_warnings_(of_)
        warning(of_, 'MolloiWarning:perfusionMode:Retrospective');
        warning(of_, 'MolloiWarning:perfusionMode:Prospective');
        warning(of_, 'MolloiWarning:volumeSelection:autoPeak');
        warning(of_, 'MolloiWarning:volumeSelection:fixedDelay');
        warning(of_, 'MolloiWarning:Registration:statusRegistration');
        warning(of_, 'MolloiWarning:FileIO:genMAT');
        warning(of_, 'MolloiWarning:FileIO:fileNotFound');
        warning(of_, 'MolloiWarning:FileIO:loadingMAT');
        warning(of_, 'MolloiWarning:FileIO:loadingDCM');
        warning(of_, 'MolloiWarning:FileIO:localPath');
        warning(of_, 'MolloiWarning:FileIO:absolutePath');
    end

end
