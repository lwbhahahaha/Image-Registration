function [ perf, perf_maps, params_v2_trigger_dt, mass, tags ] = SingleVolumePerfusion_beta( acq_path, mask_org_path, params )
% [ perf, perf_maps, mass ] = SingleVolumePerfusion( acq_path, mask_org_path, params )
% SINGLEVOLUMEPERFUSION is a specialized function used to calculate volumetric
% perfusion using a single volume and bolus tracking data

% Author: Logan Hubbard
% Edit dates:
% 05/29/21 - Addition of 3D logical erosion to myocardial to eliminate PV
% 05/29/21 - Addition of myocadial enhancement vector generation 

% 
%   INPUTS:
%
%   acq_path                      STR | '//polaris.../05_13_15_data/ACQ1'
%                                 Complete path to acquisition of interest.
%                                 Include 'REGISTERED' if necessary, it
%                                 will not be automatically appended.
%                                 *REQUIRED*
% 
%   mask_org_path                 STR | 'SEGMENT_HEART/HEART_BW.mat'
%                                 Complete path or folder path (relative to
%                                 acq_path) to segmentation volume of the
%                                 whole organ of interest.
%                                 *REQUIRED*
%
%
%   params...                     STRUCT
%                                 *OPTIONAL*
% 
%       verbose                   LOGICAL | false [DEFAULT VALUE]
%                                 Setting verbose to true will allow
%                                 warnings specific to perfusion to be
%                                 displayed.  These optional warnings
%                                 display the triggering scheme
%                                 (PROSPECTIVE/RETROSPECTIVE) used.
% 
%       aif_path                  STR | [acq_path '/Asc_Ao_autoGenerated.mat'] [DEFAULT VALUE]
%                                 Path to arterial input function OR
%                                 arterial input function mask volume.  If
%                                 the arterial input function path is
%                                 provided, it simply be loaded and used.
%                                 If the arterial input function mask path
%                                 is provided, the arterial input function
%                                 will be calculated and saved
%                                 automatically.
% 
%       time_vec_path             STR | [acq_path '/time_vec_autoGenerated.mat'] [DEFAULT VALUE]
%                                 Path to time vector to use.

%       myo_tac_path                  STR | [acq_path '/MYO_TAC_autoGenerated.mat'] [DEFAULT VALUE]
%                                 Path to time vector to use.
% 
%       xlsx_path                 STR | '//polaris.../05_13_15_data/perf_data.xlsx'
%                                 Path to excel file to save perfusion
%                                 data.  Data will 'intelligently' be
%                                 appended to the provided file path.  If
%                                 excel_path is not defined by the user, NO
%                                 DATA will be saved.
% 
%       mask_reg_path             STR | '//polaris.../05_13_15_data/17_seg/HEART_LV.mat'
%                                 Complete path to ordinal mask of regions
%                                 to calculate perfusion within.  Data of
%                                 each region will be 'intelligently'
%                                 outputted into xlsx_path.
% 
%       mask_reg_labels           {STR} | {'AHA17', 'SEG1', 'SEG2',... 'SEG17'} 
%                                 Vector-string to use as labels for
%                                 corresponding regions in mask_reg_path.
%                                 The first element of label_reg_path
%                                 will denote the sheetname in xlsx_path,
%                                 where regional perfusion data will be
%                                 outputted to.  The rest of the elements
%                                 will positionally-correspond to the
%                                 respectively numbered region ibn
%                                 mask_reg_path.  Thus, the region labeled
%                                 '1' in mask_reg_path will correspond to
%                                 'SEG1', based off the provided example.
%                                 label_reg_path is not required, even if
%                                 mask_reg_path is defined.  If
%                                 label_reg_path is not defined, a generic
%                                 naming convention will be applied, but
%                                 regional perfusion calculations will
%                                 still be performed.
% 
%       tissue_rho                DOUBLE | 1.035 g/mL [DEFAULT VALUE]
%                                 For organs where tissue denisty is
%                                 largely homogeneous, tissue_rho will
%                                 define the tissue density in g/mL.
%                                 Future iterations of this function, where
%                                 tissue is heterogeneous (like lung/brain)
%                                 relevant processing differences will need
%                                 to be addressed.
% 
%       v1_trigger_hu             DOUBLE | 300 HU [DEFAULT VALUE]
%                                 For retrospective acquisitions,
%                                 v1_trigger_hu will be the threshold, in HU, 
%                                 that will be used to determine when to 
%                                 select volume 1, for perfusion
%                                 calculations.  The true HU threshold used
%                                 to trigger V1 is calculated as the
%                                 average of the first 3 values in the AIF
%                                 PLUS v1_trigger_hu.
%
%       inj_volume                DOUBLE | 30 mL [DEFAULT VALUE]
%                                 For studies computing delay time from 1/2
%                                 the injection time. Specifically
%                                 incorportated into the gamma fit function
%                                 bounds
%
%       inj_rate                  DOUBLE | 5mL/s [DEFAULT VALUE]
%                                 For studies computing delay time from 1/2 
%                                 the injection volume. Specifically
%                                 incorportated into the gamma fit function
%                                 bounds
% 
%       v2_trigger_dt             DOUBLE | NaN sec [DEFAULT VALUE]
%                                 For prospective acquisitions,
%                                 v2_trigger_dt will be time-delay, in sec,
%                                 that will be used to determine when to
%                                 select volume 2, for perfusion
%                                 calculations.  If v2_trigger_dt is
%                                 defined as NaN, then the volume at peak
%                                 enhancement will be used to determine
%                                 volume 2.
% 
%       register                  LOGICAL | True if 'REGISTERED' acq_path [DEFAULT VALUE]
%                                 Logical parameter to indicate whether to
%                                 register the acquisition of interest.  If
%                                 register is 1, AND the acquisition is NOT
%                                 already registered (i.e. REGISTERED is
%                                 not found in acq_path) then the
%                                 acquisition will be registered.
%                                 *FUNCTIONALITY NOT IMPLEMENTED YET*
% 
%       v1_avg                    DOUBLE | NaN [DEFAULT VALUE]
%                                 If specified, v1_hu_avg will be
%                                 multiplied by volume 2, to determine
%                                 average myocardial perfusion, assuming a
%                                 uniform HU intensity in volume 1; it is a
%                                 quick work-around for cardiac datasets
%                                 that are not able to be adequately
%                                 registered together.
% 
%       aif_vec                   VECTOR(DOUBLE) | Automatically calculated [DEFAULT VALUE]
%                                 An arterial input vector can be manually
%                                 specified, if desired, but aif_vec MUST
%                                 be the same length as the generated
%                                 time_vec; if aif_vec is NOT specified,
%                                 then it is calculated using the
%                                 previously mentioned aif_vec_mask.
% 
%       vol_idx                   VECTOR(INT) | [NaN NaN] [DEFAULT VALUE]
%                                 Specify manually, which indices to use
%                                 for perfusion calculation, respectively.
% 
%       delta_time                VECTOR(INT) | [NaN] [DEFAULT VALUE]
%                                 Specify manually, the time delay between
%                                 the last scan of bolus-tacking and the second volume (peak)% 
%
%       tissue_rho_path           STR | '//polaris/data4new/../MASS_MAP.mat' 
%                                 Path to mass map to use to calculate
%                                 perfusion, where the value of each voxel
%                                 indicates the mass of that voxel, in
%                                 grams.
% 
%       filt_size_mm              SCALAR(DOUBLE) | 0 (mm) [DEFAULT VALUE]
%                                 Use to specify the length of the cube
%                                 kernel to filter perfusion maps of the
%                                 whole organ.  Refer to anatomical
%                                 dimensions (thickness of myocardium or
%                                 average width of brain, for example) to
%                                 help determine an appropriate filter
%                                 size.
%       
%       filt_type                 STR | 'MEDIAN' or 'MEAN'
%                                 By default, no filter is applied.  If
%                                 filtering of the whole organ perfusion
%                                 map is desired, specify either 'MEDIAN'
%                                 or 'MEAN'.  Futher types of filters can
%                                 be implemented in the future.
% 
%       safe_mode                 true or false | [false] [DEFAULT VALUE]
%                                 Specifying 'true' for safe_mode will
%                                 cause VolumePerfusion to run, without
%                                 raising any errors, if an error does
%                                 occur.  The updated text status
%                                 outputted to MATLAB's console will
%                                 indicate 'ERROR' rather than 'COMPLETE',
%                                 if an error does occur during the
%                                 execution of VolumePerfusion, but no
%                                 further description of the error will be
%                                 indicated.  This is ideal for robust
%                                 functionality when processing large
%                                 datasets where errors are not expected.
%                                 Specifying 'false for safe_mode will
%                                 allow errors to be raised normally.
% 
%       aux_aif_path              STR | '' [DEFAULT VALUE]
%                                 Path to arterial input function OR
%                                 arterial input function mask volume.  If
%                                 the arterial input function path is
%                                 provided, it simply be loaded and used.
%                                 If the arterial input function mask path
%                                 is provided, the arterial input function
%                                 will be calculated and saved
%                                 automatically.  Specifically, this
%                                 parameter is used to specify
%                                 VolumePerfusion to use an auxilairy input
%                                 function, to be used to select V1.  In
%                                 cardiac perfusion, we commonly use the
%                                 left atrium AIF to select V1, but we
%                                 still use the aortic AIF to calculate the
%                                 input concentration.
% 
%       perf_ref_path             STRUCT | EMPTY [DEFAULT VALUE]
%                                 Specify the path to reference standard
%                                 regional perfusion measurements.  Each
%                                 element in this struct should be labeled,
%                                 according to the inputted
%                                 mask_reg_labels, and each elements
%                                 associated value should correspond to
%                                 that region's reference standard
%                                 perfusion measurement (usually from
%                                 microsphere data)
%
%       
%       input_conc_type           STR | 'TRAPEZOID' or 'TRIANGLE' or
%                                 'INTEGRAL' or 'GAMMA'. By default, the average input
%                                 concentration is used. If a different input
%                                 concentration caluculation method is desired
%                                 specify 'TRAPEZOID' or 'TRIANGLE' or
%                                 'INTEGRAL' or 'GAMMA'.
%

%   OUTPUTS:
%
%   perf...                       STRUCT
% 
%       whole_organ               DOUBLE | #.## mL/(min * g)
%                                 Calculation of perfusion into
%                                 whole-organ.
% 
%    *REGIONAL PERFUSION MEASUREMENTS*  
% 
%       region1                   DOUBLE | #.## mL/(min *g)
%                                 Calculation of perfusion into region1, as
%                                 defined by mask_reg_path.  If
%                                 mask_reg_path is not provided, regional
%                                 perfusion elements of the variable perf
%                                 will not be defined.
% 
%       region2
%       .
%       .
%       .
%       regionN
%
%
%   perf_maps...                  STRUCT
% 
%       whole_organ               VOLUME(DOUBLE) | 512x512x320 mL/(min * g)
%                                 Volume-map of perfusion in whole organ of
%                                 interest.  No post-processing will be
%                                 provided for any perf_maps.  Further
%                                 processing of perf_maps, such as smoothing
%                                 or writing as DICOM files, should be
%                                 performed OUTSIDE this function.
% 
%    *REGIONAL PERFUSION MAPS*
% 
%       region1                   VOLUME(DOUBLE) | 512x512x320 mL/(min * g)
%                                 Volume-map of perfusion in region of
%                                 interest.  No post-processing will be
%                                 provided for any perf_maps.  Further
%                                 processing of perf_maps, such as smoothing
%                                 or writing as DICOM files, should be
%                                 performed OUTSIDE this function.
% 
%       region2
%       .
%       .
%       .
%       regionN
%
%   AUTHORS:       Logan Hubbard Shant Malkasian

%   DATE UPDATED: 30-April-2021
%

TP_info = 'VolumePerfusion | ';
cur_TP = TextProgressbar(TP_info);
% SECTION 0: INITIALIZE
cur_step = 'Initializing variables...';
cur_TP.update(cur_step);

% 0.1: Pre-process acq_path and mask_org_path
acq_path = process_path(acq_path);
mask_org_path = process_path(mask_org_path);

% 0.2: Define default parameters (TODO: Make default parameters same type
% as expected parameter, it makes life easier...)
params_verbose = false;
params_aif_path = [acq_path '/Asc_Ao_autoGenerated.mat'];
params_time_vec_path = [acq_path '/time_vector_autoGenerated.mat'];
params_myo_tac_path = [acq_path '/MYO_TAC_autoGenerated.mat'];
params_xlsx_path = false;
params_mask_reg_path = false;
params_mask_reg_labels = false;
params_tissue_rho = 1.053; % g/mL
params_v1_trigger_hu = 140; % HU
params_v1_offset = 0;
params_inj_volume = NaN; % mL, minimum
params_inj_rate = NaN; %mL/s, most studies used this rate
params_v2_trigger_dt = NaN; % sec
params_v2_adj_n = 0;
params_v2_peak_offset = 0;
params_aif_vec = [NaN NaN];
params_avg_v1 = [false NaN];
params_register = is_acq_registered(acq_path); % TODO: Integrate registration
params_vol_idx = [NaN NaN];
params_tissue_rho_path = '';
params_safe_mode = false;
params_filt_size_mm = 0;
params_filt_type = '';
params_input_conc_type = ''; % This is a new addition, default is set to nothing
params_xlsx_main_path = false;
params_xlsx_add_col = {};
params_aux_aif_vec = [NaN NaN];
params_aux_aif_path = '';
params_aux_aif_delay = 2.00; % SEC
params_perf_ref_path = '';
params_delta_time = NaN;
params_helical = false;
% params_reg_groups = '';

% 0.3: If user specified optional parameters, overwrite default parameters
if nargin == 3  
    usr_vars = fieldnames(params);
    % CHECK THAT USER DEFINED ALLOWABLE PARAMETERS
    check_params_(params, 'params_');
    
    % ADD OPTIONAL PARAMETERS TO DEFINE HERE
    % TODO:  ALPHABETIZE
    if any(strcmp(usr_vars, 'verbose'))
        params_verbose = params.verbose;
    end
    if any(strcmp(usr_vars, 'aif_path'))
        params_aif_path = process_path(params.aif_path);
    end
    if any(strcmp(usr_vars, 'time_vec_path'))
        params_time_vec_path = process_path(params.time_vec_path);
    end
    if any(strcmp(usr_vars, 'myo_tac_path'))
        params_myo_tac_path = process_path(params.myo_tac_path);
    end
    if any(strcmp(usr_vars, 'xlsx_path'))
        params_xlsx_path = process_path(params.xlsx_path);
    end
    if any(strcmp(usr_vars, 'mask_reg_path'))
        params_mask_reg_path = process_path(params.mask_reg_path);
    end
    if any(strcmp(usr_vars, 'mask_reg_labels'))
        params_mask_reg_labels = params.mask_reg_labels;
    end
    if any(strcmp(usr_vars, 'tissue_rho'))
        params_tissue_rho = params.tissue_rho;
    end
    if any(strcmp(usr_vars, 'v1_trigger_hu'))
        params_v1_trigger_hu = params.v1_trigger_hu;
    end
    if any(strcmp(usr_vars, 'inj_volume'))
        params_inj_volume = params.inj_volume;
    end
    if any(strcmp(usr_vars, 'inj_rate'))
        params_inj_rate = params.inj_rate;
    end
    if any(strcmp(usr_vars, 'v2_trigger_dt'))
        params_v2_trigger_dt = params.v2_trigger_dt;
    end
    if any(strcmp(usr_vars, 'register'))
        params_register = params.register;
    end
    if any(strcmp(usr_vars, 'aif_vec'))
        params_aif_vec = params.aif_vec;
    end
    if any(strcmp(usr_vars, 'avg_v1'))
        if isnumeric(params.avg_v1) & ~isnan(params.avg_v1) & isscalar(params.avg_v1)
            params_avg_v1 = [true params.avg_v1];
        else
            params_avg_v1 = [params.avg_v1 NaN];
        end 
    end
    if any(strcmp(usr_vars, 'vol_idx'))
        params_vol_idx = params.vol_idx;
    end
    if any(strcmp(usr_vars, 'delta_time'))
        params_delta_time = params.delta_time;
    end
    if any(strcmp(usr_vars, 'tissue_rho_path'))
        params_tissue_rho_path = process_path(params.tissue_rho_path);
    end
    if any(strcmp(usr_vars, 'safe_mode'))
        params_safe_mode = params.safe_mode;
    end
    if any(strcmp(usr_vars, 'filt_size_mm'))
        params_filt_size_mm = params.filt_size_mm;
    end
    if any(strcmp(usr_vars, 'filt_type'))
        params_filt_type = params.filt_type;
    end
    if any(strcmp(usr_vars, 'input_conc_type')) %This is a new addition
        params_input_conc_type = params.input_conc_type;
    end
    if any(strcmp(usr_vars, 'xlsx_main_path'))
        params_xlsx_main_path = params.xlsx_main_path;
    end
    if any(strcmp(usr_vars, 'xlsx_add_col'))
        params_xlsx_add_col = params.xlsx_add_col;
    end
    if any(strcmp(usr_vars, 'aux_aif_vec'))
        params_aux_aif_vec = params.aux_aif_vec;
    end
    if any(strcmp(usr_vars, 'aux_aif_path'))
        params_aux_aif_path = process_path(params.aux_aif_path);
    end
    if any(strcmp(usr_vars, 'perf_ref_path'))
        params_perf_ref_path = process_path(params.perf_ref_path);
    end
     if any(strcmp(usr_vars, 'helical_mode'))
        params_helical = params.helical_mode;
     end
end

% try
% 0.4: Enable/Disable status warnings based on user's VERBOSE specification
warning('off', 'MATLAB:xlswrite:AddSheet'); % always disable because its annoying...
if params_verbose
    toggle_warnings_('on');
else
    toggle_warnings_('off');
end

% SECTION 1: LOAD FILES
try
cur_step = 'Loading files...';
cur_TP.update(cur_step);

% % 1.1: Load voxel size
% cur_step = strrep(cur_step, '...', ' | Loading MAT files...');
% cur_TP.update(cur_step);
params_vx_size = get_vx_size([acq_path '/DICOM/']);  
if params_helical ~= 0
    params_vx_size(3) = 0.3;
end

% 1.X: (TODO) Register dataset, if specified and dataset is NOT registered
if params_register & ~is_acq_registered(acq_path)
    % Register acqisition here
    molloi_warning('Registration:statusRegistration', 'Registration Status',...
        'Integration of registration functionality has not been implemented yet\n');
end

% 1.2: Loading organ mask binary volume
cur_step = strrep(cur_step, '...', ' | Loading Organ Mask...');
cur_TP.update(cur_step);
mask_org_path = verify_path(acq_path, mask_org_path, 'OrganMask');
organ_mask = load_volume(mask_org_path);

% 1.2.1: 3D Erosion of binary organ mask to eliminate partial volume effects
organ_mask = organ_mask > 0; % Creation of logical mask
% SE = strel('sphere',2); % Creates a sphere-shaped structuring element whose radius is R pixels
% organ_mask = imerode(organ_mask,SE); %Erode inner and outer edges of myocardium

% 1.3: Loading mass map, if specified
if ~isempty(params_tissue_rho_path)
    cur_step = strrep(cur_step, '...', ' | Loading Mass Map...');
    cur_TP.update(cur_step);
    params_tissue_rho_path = verify_path(acq_path, params_tissue_rho_path, 'MassMap');
    params_tissue_rho = load_volume(params_tissue_rho_path);
end

% 1.4: Make sure all MATs for time-series are generated
cur_step = strrep(cur_step, '...', ' | Checking Time-Series MATs...');
cur_TP.update(cur_step);
% gen_mat(acq_path);

% 1.5: Loading AIF or generate AIF if it doesn't exist
% PRIMARY AIF
if any(isnan(params_aif_vec))
    cur_step = strrep(cur_step, '...', ' | Loading Primary AIF...');
    cur_TP.update(cur_step);
    aif_vec = load_aif(params_aif_path, acq_path);
else
    aif_vec = params_aif_vec;
end

%Make a column vector
if size(aif_vec,1) > size(aif_vec,2)
    aif_vec = aif_vec';
end
    
% AUX AIF
if any(isnan(params_aux_aif_vec)) && ~isempty(params_aux_aif_path)
    cur_step = strrep(cur_step, '...', ' | Loading Auxiliary AIF...');
    cur_TP.update(cur_step);
    aux_aif_vec = load_aif(params_aux_aif_path, acq_path);
else
    aux_aif_vec = params_aux_aif_vec;
end


% 1.6: Loading time vector, or creating it, if it doesn't exist
cur_step = strrep(cur_step, '...', ' | Loading Time Vector...');
cur_TP.update(cur_step);
time_vec = load_time_vec(params_time_vec_path, acq_path);

%Make a column vector
if size(time_vec,1) > size(time_vec,2)
    time_vec = time_vec';
end


% 1.7: Loading MYO TAC or generate MYO TAC if it doesn't exist
cur_step = strrep(cur_step, '...', ' | Loading Myocardial TAC...');
cur_TP.update(cur_step);
myo_tac_vec = load_myo_tac(params_myo_tac_path, acq_path);

%Make a column vector
if size(myo_tac_vec,1) > size(myo_tac_vec,2)
    myo_tac_vec = myo_tac_vec';
end


% 1.8: Loading reference perfusion measurements, if specified
perf_ref = { };
if ~isempty(params_perf_ref_path)
    cur_step = strrep(cur_step, '...', ' | Loading Reference Measurements...');
    cur_TP.update(cur_step);
    params_perf_ref_path = verify_path(acq_path, params_perf_ref_path, 'Reference');
    perf_ref = load_volume(params_perf_ref_path);
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end

% SECTION 2: Specify v1_idx AND determin v2_idx
% 2.1: Specify V1 and determine V2 indices

try
cur_step = 'Determining volume indices...';
cur_TP.update(cur_step);

% Check delay parameter first
peak_idx = find(aif_vec == max(aif_vec));
% baseline_range = 3; % GET BASELINE ATTENUATION FROM FIRST 3 AIF ENTRIES
% if (params_v1_trigger_hu + mean(aif_vec(1:baseline_range))) > max(aif_vec)
%         params_v1_trigger_hu = 0;
% else
%         params_v1_trigger_hu_temp = params_v1_trigger_hu + mean(aif_vec(1:baseline_range));
% end
% trigger_time = min(time_vec(aif_vec >= params_v1_trigger_hu_temp) + params_v1_offset);
% trigger_idx = find((time_vec - trigger_time) >= 0, 1, 'first') + params_v1_offset;

% If the trigger time + delay time exceed the true peak time, just use the
% peak idx for the remainder of calculations.
% if (time_vec(trigger_idx) + params_v2_trigger_dt) >= time_vec(peak_idx)
%     params_v2_trigger_dt = NaN;
% end
trigger_time = time_vec(end - 1);
trigger_idx = length(time_vec) - 1;

if any(isnan(params_vol_idx))
    [v1_idx, v2_idx, params_perf_mode] = select_vol_idx(aif_vec, time_vec, params_v1_trigger_hu, params_v1_offset, 0, params_v2_trigger_dt);
    if ~any(isnan(aux_aif_vec))
        % AUXILIARY AIF PROVIDED, USE IT TO RECALCULATE V1_IDX
        params_perf_mode = 'RETRO_AUX_AIF';
        params_v1_offset = 0;
        [v1_idx, v2_idx] = select_vol_idx(aux_aif_vec, time_vec, params_v1_trigger_hu, params_v1_offset, params_aux_aif_delay, params_v2_trigger_dt);
    end
end

% %%%%% At this point, v1_idx has been determined based on triggering, and
% %%%%% v2_idx has been determined based on delay or peak occurance. Need to
% %%%%% store trigger time...
% trigger_idx = v1_idx;

% 2.2: Determine if user specified manual selection of V1 and V2, and
% overwrite previously calculated V1 and V2
if ~isnan(params_vol_idx(1)) && any(isnan(aux_aif_vec))
    v1_idx = params_vol_idx(1); % This should update to 1 -- the non-con volume
    params_perf_mode = 'MANUAL_V1';
end
if ~isnan(params_vol_idx(2))
    v2_idx = params_vol_idx(2);
    params_perf_mode = 'MANUAL_V2';
end
if all(~isnan(params_vol_idx)) && any(isnan(aux_aif_vec))
    params_perf_mode = 'MANUAL';
end


%2.3: Add v2 peak offset, if PerfMode is RETRO
if strcmp(params_perf_mode, 'RETRO') % || strcmp(params_perf_mode, 'MANUAL_V1')
    if isnan(params_v2_trigger_dt)
        v2_idx = v2_idx + params_v2_peak_offset; % Should bypass this as V2_idx already defined
    end
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end

% SECTION 3: CALCULATE INPUT CONCENTRATION AND DELTA TIME
% This is where the major updates are going to occur...
% Different ideas are
    % 1) Trapezoidal approximation
    % 2) Extrapolated triangle approximation
    % 3) Discrete area under the curve approximation
    % 4) Gamma variate fit approximation

    
try
cur_step = 'Calculating input concentration...';
cur_TP.update(cur_step);

if (length(aif_vec) > 2) && ~isempty(params_input_conc_type)
    switch params_input_conc_type
        case 'TRAPEZOID' % Option 1 - Trapezoidal Approximation
            % Compute baseline blood pool enhancement
            range = 3;
            baseline_blood_hu = mean(aif_vec(1:range));
            %Compute triangular area
            area_triangle = ((aif_vec(v2_idx) - aif_vec(trigger_idx)).*(time_vec(v2_idx) - time_vec(trigger_idx)))./2;
            %Compute rectangular area
            area_rectangle = ((aif_vec(trigger_idx) - baseline_blood_hu).*(time_vec(v2_idx) - time_vec(trigger_idx)));
            area_total = area_triangle + area_rectangle;
            input_conc = area_total./(time_vec(v2_idx) - time_vec(trigger_idx));
            delta_time = (time_vec(v2_idx) - time_vec(trigger_idx)); % dT is just back to the trigger time
            
            % For plotting...
            % Build new aif_vec and time_vecs trucated at the trigger with
            % concatenation of V2
            aif_vec_new = aif_vec(1:trigger_idx);
            aif_vec_new = [aif_vec_new aif_vec(v2_idx)]; 
            time_vec_new = time_vec(1:trigger_idx); 
            time_vec_new = [time_vec_new time_vec(v2_idx)];
            time_fit = [time_vec(trigger_idx) time_vec(v2_idx)];
            aif_fit = [aif_vec(trigger_idx) aif_vec(v2_idx)];
     
            % Plot Data
            figure(1);
            % Plot Original Complete AIF data
            plot(time_vec,aif_vec,'k-','LineWidth',2); hold on;
            % Plot MYO TAC Data
            plot(time_vec,myo_tac_vec,'g-','LineWidth',2);hold on;
            % Plot 'Bolus Tracking' Data
            plot(time_vec_new,aif_vec_new,'ko', 'MarkerSize',8); hold on;
            % Plot Fit Function
            plot(time_fit,aif_fit,'k:','LineWidth',2); hold on; %May need to modify
            % Plot AUC of Integration
            a = area(time_fit,aif_fit,baseline_blood_hu); hold on;
            a.FaceColor = 'cyan';
            a.FaceAlpha = 0.2;
            % Plot Trigger Point  
            plot(time_vec(trigger_idx),aif_vec(trigger_idx),'bs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','b','MarkerSize',12); hold on;
            % Plot V2 Point
            plot(time_vec(v2_idx),aif_vec(v2_idx),'rs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','r','MarkerSize',12);  hold on;    
            % Add legend
            legend('AIF DATA','TAC DATA','FIT DATA','FIT CURVE','AUC','TRIGGER','V2','Location','Northwest');
            xlim([0 time_vec(end)]);
            xlabel('Time (s)');
            ylabel('Aortic Enhancement (HU)');
            pause(2);
    
            % Save figure:
            label1 = num2str(params_v1_trigger_hu);
            label2 = num2str(params_v2_trigger_dt);
            if isnan(params_v2_trigger_dt)
                label2 = 'PEAK';
                saveas(figure(1), [acq_path '/FIGURES/TRAPEZOID_FIT_TRIGGER_' label1 'HU_DELAY_' label2 '.fig']);
            else 
                saveas(figure(1), [acq_path '/FIGURES/TRAPEZOID_FIT_TRIGGER_' label1 'HU_DELAY_' label2 's.fig']);
            end
            close all;
            

        case 'TRIANGLE' % Option 2 - Extrapolated Triangle Approximation 
            % Compute baseline blood pool enhancement
            range = 3;
            baseline_blood_hu = mean(aif_vec(1:range));
            %Extrapolate and solve for time intercept with baseline blood pool
            slope = (aif_vec(v2_idx) - aif_vec(trigger_idx))./(time_vec(v2_idx) - time_vec(trigger_idx));
            time_intercept = (baseline_blood_hu./slope) - (aif_vec(trigger_idx)./slope) + time_vec(trigger_idx);
            %Compute triangular area
            area_triangle = ((aif_vec(v2_idx) - baseline_blood_hu).*(time_vec(v2_idx) - time_intercept))./2;
            input_conc = area_triangle./(time_vec(v2_idx) - time_intercept);
            delta_time = (time_vec(v2_idx) - time_intercept); % dT goes back to the extrapolation
            
            % For plotting...
            % Build new aif_vec and time_vecs trucated at the trigger with
            % concatenation of V2
            aif_vec_new = aif_vec(1:trigger_idx);
            aif_vec_new = [aif_vec_new aif_vec(v2_idx)]; 
            time_vec_new = time_vec(1:trigger_idx); 
            time_vec_new = [time_vec_new time_vec(v2_idx)];
            time_fit = [time_intercept time_vec(v2_idx)];
            aif_fit = [baseline_blood_hu aif_vec(v2_idx)];
            
            % Plot Data
            figure(1);
            % Plot Original Complete AIF data
            plot(time_vec,aif_vec,'k-','LineWidth',2); hold on;
            % Plot MYO TAC Data
            plot(time_vec,myo_tac_vec,'g-','LineWidth',2); hold on;
            % Plot 'Bolus Tracking' Data
            plot(time_vec_new,aif_vec_new,'ko', 'MarkerSize',8); hold on;
            % Plot Fit Function
            plot(time_fit,aif_fit,'k:','LineWidth',2); hold on; %May need to modify
            % Plot AUC of Integration
            a = area(time_fit,aif_fit,baseline_blood_hu); hold on;
            a.FaceColor = 'cyan';
            a.FaceAlpha = 0.2;
            % Plot Trigger Point  
            plot(time_vec(trigger_idx),aif_vec(trigger_idx),'bs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','b','MarkerSize',12); hold on;
            % Plot V2 Point
            plot(time_vec(v2_idx),aif_vec(v2_idx),'rs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','r','MarkerSize',12);  hold on;    
            % Add legend
            legend('AIF DATA','TAC DATA','FIT DATA','FIT CURVE','AUC','TRIGGER','V2','Location','Northwest');
            xlim([0 time_vec(end)]);
            xlabel('Time (s)');
            ylabel('Aortic Enhancement (HU)');
            pause(2);
    
            % Save figure:
            label1 = num2str(params_v1_trigger_hu);
            label2 = num2str(params_v2_trigger_dt);
            if isnan(params_v2_trigger_dt)
                label2 = 'PEAK';
                saveas(figure(1), [acq_path '/FIGURES/TRIANGLE_FIT_TRIGGER_' label1 'HU_DELAY_' label2 '.fig']);
            else 
                saveas(figure(1), [acq_path '/FIGURES/TRIANGLE_FIT_TRIGGER_' label1 'HU_DELAY_' label2 's.fig']);
            end
            close all;
            
    
        case 'INTEGRAL' % Option 3 - Discrete Area-Under-The-Curve Approximation
            % Compute baseline blood pool enhancement
            range = 3;
            baseline_blood_hu = mean(aif_vec(1:range));
            %Substract off baseline blood enhancement bias before integration
            aif_vec = aif_vec - baseline_blood_hu;
            
            % Build new aif_vec and time_vecs trucated at the trigger with
            % concatenation of V2
            aif_vec_new = aif_vec(1:trigger_idx);
            aif_vec_new = [aif_vec_new aif_vec(v2_idx)]; 
            time_vec_new = time_vec(1:trigger_idx); 
            time_vec_new = [time_vec_new time_vec(v2_idx)]; 
            
            % Find Integration Start Point
            % Function initialization
            gamma = @(gm,time)((gm(1).*(time./gm(2)).^gm(3)).*exp(gm(3).*(1-time./gm(2)))+gm(4));
            % Initialize AIF fit parameters
            gm1 = aif_vec_new(end); %Peak occurance....minimum is last point on bolus tracking
            gm2 = time_vec_new(end); %Peak occurance....minium is last point on Bolus Tracking
            gm3 = 0; %Growth Factor
            gm4 = 0; %Blood pool offset has been removed
            gm0 = [gm1, gm2, gm3, gm4]; %Intial conditions
            
            % Upper and Lower Bounds
            gmlb = [aif_vec_new(end),time_vec_new(end),-100,0];
            gmub = [aif_vec_new(end),time_vec_new(end),100,200]; %Peak
           
            if ~isnan(params_inj_volume) & ~isnan(params_inj_rate)
                
                half_inj_time = 0.5 * params_inj_volume ./ params_inj_rate;
                
                if ~isnan(params_v2_trigger_dt)
                    
                    if params_v2_trigger_dt <= half_inj_time
                        gmub = [aif_vec_new(end),1.10.*time_vec_new(end),100,200];
                    end
                    if params_v2_trigger_dt > half_inj_time
                        gmub = [aif_vec_new(end),1.05.*time_vec_new(end),100,200]; %Rough first approximation
                    end
                    
                else
                    gmub = [aif_vec_new(end),time_vec_new(end),100,200]; %Peak
                end
            end
                   
            % Gamma Fit
            gamma_coef = lsqcurvefit(gamma,gm0,time_vec_new,aif_vec_new,gmlb,gmub);
            gamma_fit = gamma(gamma_coef,time_vec_new);
            %Remove baseline and find start index
            gamma_fit_temp = gamma_fit - gamma_coef(4);
            threshold = 100; %%%%%% THIS CAN POSSIBLY BE CHANGED?
            int_time = min(time_vec_new(gamma_fit_temp >= threshold));
            int_idx = find((time_vec_new - int_time) >= 0, 1, 'first');
                       
            % Compute trapezoidal integration of AUC from int_time to V2
            area_total = trapz(time_vec_new(int_idx:end), aif_vec_new(int_idx:end)); 
            input_conc = area_total./(time_vec_new(end) - time_vec_new(int_idx));
            delta_time = (time_vec_new(end) - time_vec_new(int_idx)); % dT goes all the way back to 0
            
            %Update Data for Plotting Purposes
            aif_vec = aif_vec + baseline_blood_hu;
            aif_vec_new = aif_vec_new + baseline_blood_hu;
            
            % Plot Data
            figure(1);
            % Plot Original Complete AIF data
            plot(time_vec,aif_vec,'k-','LineWidth',2); hold on;
            % Plot MYO TAC Data
            plot(time_vec,myo_tac_vec,'g-','LineWidth',2); hold on;
            % Plot 'Bolus Tracking' Data
            plot(time_vec_new,aif_vec_new,'ko', 'MarkerSize',8); hold on;
            % Plot Fit Function
            plot(time_vec_new(int_idx:end),aif_vec_new(int_idx:end),'k:','LineWidth',2); hold on; %May need to modify
            % Plot AUC of Integration
            a = area(time_vec_new(int_idx:end),aif_vec_new(int_idx:end),baseline_blood_hu); hold on;
            a.FaceColor = 'cyan';
            a.FaceAlpha = 0.2;
            % Plot Trigger Point  
            plot(time_vec(trigger_idx),aif_vec(trigger_idx),'bs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','b','MarkerSize',12); hold on;
            % Plot V2 Point
            plot(time_vec(v2_idx),aif_vec(v2_idx),'rs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','r','MarkerSize',12);  hold on;    
            % Add legend
            legend('AIF DATA','TAC DATA','FIT DATA','FIT CURVE','AUC','TRIGGER','V2','Location','Northwest');
            xlim([0 time_vec(end)]);
            xlabel('Time (s)');
            ylabel('Aortic Enhancement (HU)');
            pause(2);
    
            % Save figure:
            label1 = num2str(params_v1_trigger_hu);
            label2 = num2str(params_v2_trigger_dt);
            if isnan(params_v2_trigger_dt)
                label2 = 'PEAK';
                saveas(figure(1), [acq_path '/FIGURES/DISCRETE_FIT_TRIGGER_' label1 'HU_DELAY_' label2 '.fig']);
            else 
                saveas(figure(1), [acq_path '/FIGURES/DISCRETE_FIT_TRIGGER_' label1 'HU_DELAY_' label2 's.fig']);
            end
            close all;
            clc;
            
            
        case 'GAMMA' %Option 4 - Gamma Variate Area-Under-The-Curve Approximation
            % Compute baseline blood pool enhancement
            range = 3;
            baseline_blood_hu = mean(aif_vec(1:range));
            
            % Build new aif_vec and time_vecs trucated at the trigger with
            % concatenation of V2
            aif_vec_new = aif_vec(1:trigger_idx);
            aif_vec_new = [aif_vec_new aif_vec(v2_idx)]; 
            time_vec_new = time_vec(1:trigger_idx); 
            time_vec_new = [time_vec_new time_vec(v2_idx)];  
            
            aif_vec_new = aif_vec;
            time_vec_new = time_vec; 
            v2_idx = peak_idx;
            
            % Constrained function initialization. This version will be
            % algebraically contrained to pass directly through the V2
            % index point. By plugging in (x,y) at V2_idx to:
            % gamma = @(gm,time)((gm(1).*(time./gm(2)).^gm(3)).*exp(gm(3).*(1-time./gm(2)))+gm(4));
            % We can solve for gm(1) --> A
            % A = (aif_vec_new(end) - gm(4)) ./ (((time_vec_new(end)./gm(2)).^gm(3)).*(exp(gm(3).*(1-(time_vec_new(end)./gm(2))))))
            % and plug the expression back in to the expression to yield
            % the contrained function:                      
            gamma = @(gm,time)( ((aif_vec_new(end) - gm(3)) ./ (((time_vec_new(end)./gm(1)).^gm(2)).*(exp(gm(2).*(1-(time_vec_new(end)./gm(1))))))).*((time./gm(1)).^gm(2)).*(exp(gm(2).*(1-(time./gm(1))))) + gm(3) );
            % Initialize AIF fit parameters
            gm1 = time_vec_new(end); %Peak occurance....minium is last point on Bolus Tracking
            gm2 = 0; % Growth factor
            gm3 = baseline_blood_hu; %Blood pool offset 
            gm0 = [gm1, gm2, gm3]; %Intial conditions
            
            % Upper and Lower Bounds
            gmlb = [gm1,-100,0];
            gmub = [gm1,100,200]; % Forcing peak at point
           
            if ~isnan(params_inj_volume) & ~isnan(params_inj_rate)
                
                half_inj_time = 0.5 * params_inj_volume ./ params_inj_rate;
                
                if ~isnan(params_v2_trigger_dt)
                    
                    if params_v2_trigger_dt <= half_inj_time
                        gmub = [1.10.*gm1,100,200];
                    end
                    if params_v2_trigger_dt > half_inj_time
                        gmub = [1.05.*gm1,100,200]; %Rough first approximation
                    end
                    
                else
                    gmub = [gm1,100,200]; %Peak
                end
            end
             
            %%%%%% Gamma Fit
            % Initialize time vector 3 samples per second and use for fit
            % with higher time sample density used for later area integration
            gamma_coef = lsqcurvefit(gamma,gm0,time_vec_new,aif_vec_new,gmlb,gmub);
            %time = linspace(time_vec(1),time_vec(end),round(max(time_vec)*3));
            time = linspace(time_vec(1),time_vec(end),round(max(time_vec)*1));
            gamma_fit = gamma(gamma_coef,time);
            
            %Remove baseline and find start index (more accurate now that
            %linspace has been used to generate finer time vector)
%             gamma_fit_temp = gamma_fit - gamma_coef(3);
%             threshold = 200; %%%%%% SEEMS CORRECT...200
%             int_time = min(time(gamma_fit_temp >= threshold));
%             int_idx = find((time - int_time) >= 0, 1, 'first');
            
            int_idx = find((time - trigger_time + 3) >= 0, 1, 'first');
          
            % Check output data of interest
            trigger_blood = gamma_coef(3) + params_v1_trigger_hu; %offset in blood for triggering
            if trigger_blood > aif_vec(v2_idx)
                disp(['High Trigger Threshold: Terminating AIFAnalysis for' acq_path]) % Test first to see if triggering was bad to start... throw acqusition out 
            return;
            end
            
            % Area of Fit Function from int_time to V2. Plug in coefficients
            % and integrate over time interval of interest.        
            fit = @(time)( ((aif_vec(v2_idx) - gamma_coef(3)) ./ (((time_vec(v2_idx)./gamma_coef(1)).^gamma_coef(2)).*(exp(gamma_coef(2).*(1-(time_vec(v2_idx)./gamma_coef(1))))))).*((time./gamma_coef(1)).^gamma_coef(2)).*(exp(gamma_coef(2).*(1-(time./gamma_coef(1))))) + gamma_coef(3) );
            area_fit = integral(fit,time(int_idx),time_vec(v2_idx)); % This time is most accurate, integration includes baseline area
            area_rectangle = (time_vec(v2_idx) - time(int_idx)).*gamma_coef(3); 
            area_total = area_fit - area_rectangle; % Subtract off the baseline
            input_conc = area_total./(time_vec(v2_idx) - time(int_idx));
            delta_time = (time_vec(v2_idx) - time(int_idx)); 
                       
            % Plot Data
            figure(1);
            % Plot V1 Point
%             time_vec_v1 = [-0.7,-0.35,time_vec];
%             aif_vec_v1 = [aif_vec(1),aif_vec(1),aif_vec];
%             plot(time_vec_v1(1),aif_vec_v1(1),'ys','MarkerEdgeColor','k',...
%                        'MarkerFaceColor','y','MarkerSize',12);  hold on;  
            % Plot Original Complete AIF data
%             plot(time_vec,aif_vec,'ko','MarkerSize',6); hold on;
            % Plot Fit Function); hold on;       
%             % Plot MYO TAC Data
%             plot(time_vec,myo_tac_vec,'g-','LineWidth',2);hold on;
            % Plot 'Bolus Tracking' Data Fed into Fit Function
            plot(time_vec_new([3:end]),aif_vec_new([3:end]),'ko', 'MarkerSize',8); hold on;
            % Plot Fit Function
            plot(time,gamma(gamma_coef,time),'k:','LineWidth',3); hold on;
            % Plot AUC of Integration
            time_temp = linspace(time(int_idx),time_vec(v2_idx),round(max(time_vec)*1));
            a = area(time_temp(1:end),gamma(gamma_coef,time_temp(1:end)),gamma_coef(3)); hold on;
            a.FaceColor = 'cyan';
            a.FaceAlpha = 0.2;
        
            % Plot Trigger Point  
            plot(time_vec(trigger_idx),aif_vec(trigger_idx),'bs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','b','MarkerSize',12); hold on;
            % Plot V2 Point
            plot(time_vec(v2_idx),aif_vec(v2_idx),'rs','MarkerEdgeColor','k',...
                       'MarkerFaceColor','r','MarkerSize',12);  hold on;    
            % Add legend
%             legend('V1','BOLUS TRACKING','FIT CURVE','AUC','TRIGGER','V2','Location','Northwest');
%             xlim([-0.9 time_vec(end)]);
            legend('BOLUS TRACKING','FIT CURVE','AUC','TRIGGER','VOLUME SCAN','Location','Northwest');
            xlim([0 time_vec(end)]);
            xlabel('Time (s)', 'fontsize', 12);
            ylabel('Aortic Enhancement (HU)', 'fontsize', 12);
            pause(2);
    
            % Save figure:
            label1 = num2str(params_v1_trigger_hu);
            label2 = num2str(params_v2_trigger_dt);
            if ~exist([acq_path '/FIGURES'], 'file')
                mkdir([acq_path '/FIGURES'])
            end
            if isnan(params_v2_trigger_dt)
                label2 = 'PEAK';
                saveas(figure(1), [acq_path '/FIGURES/GAMMA_FIT_TRIGGER_' label1 'HU_DELAY_' label2 '.fig']);
            else 
                saveas(figure(1), [acq_path '/FIGURES/GAMMA_FIT_TRIGGER_' label1 'HU_DELAY_' label2 's.fig']);
            end
           close all;
           clc;
    end
    
elseif (length(aif_vec) > 2) && isempty(params_input_conc_type)
    input_conc = mean([aif_vec(v2_idx) aif_vec(trigger_idx)]);
    delta_time = (time_vec(v2_idx) - time_vec(trigger_idx)); % This remains correct

elseif (length(aif_vec) == 2) && isempty(params_input_conc_type)
    input_conc = mean([aif_vec(1) aif_vec(2)]); % If manual, only use 1st indeces
    delta_time = (time_vec(v2_idx) - time_vec(v1_idx)); % This remains correct

    
end


if ~isnan(params_delta_time)
    delta_time = params_delta_time;
    input_conc = mean([aif_vec(trigger_idx) aif_vec(v2_idx)]);

else
    delta_time = (time_vec(v2_idx) - time_vec(v1_idx));
    input_conc = mean([aif_vec(v1_idx) aif_vec(v2_idx)]);

end

catch ME
    delete(cur_TP, 'ERROR\n');
    if ~params_safe_mode
        throw(ME);
    end
end

% SECTION 4: LOAD V1 AND V2
try
cur_step = 'Loading volumes 1 and 2...';
cur_TP.update(cur_step);

% 4.1: Load volumes
if  v2_idx ~= params_vol_idx(2)
    v2_idx = params_vol_idx(2);
end

% For single volume scan
if  params_avg_v1(1) ~= 0
    v1_idx = 2;
    v2_idx = 2;
end

v1_vol = load_volume_idx(acq_path, v1_idx); % This is the non-con
v2_vol = load_volume_idx(acq_path, v2_idx); % This remains correct


% 4.2: Distribute uniform HU intensity for V1, if specified
v2_vol(~organ_mask) = 0;
if params_avg_v1(1)
    if ~isnan(params_avg_v1(2))
        v1_vol = double(organ_mask) .* params_avg_v1(2); % This remains correct
    else
        v1_vol = double(organ_mask) .* mean(v1_vol(organ_mask));
    end
else
    v1_vol(~organ_mask) = 0;
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end

% SECTION 5: CALCULATE WHOLE-ORGAN PERFUSION
try
cur_step = 'Calculating perfusion...';
cur_TP.update(cur_step);

% 5.1:  Calculate whole-organ perfusion, perfusion map, mass and change in
% Hounsfield Units (ALWAYS V2 - V1)

[perf.whole_organ, perf_maps.whole_organ, mass.whole_organ, change_hu.whole_organ] = calc_organ_perfusion(v1_vol, v2_vol,...
                                                                                    organ_mask, input_conc, params_tissue_rho,...
                                                                                    params_vx_size, delta_time);
catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end


% SECTION 6: GENERATE TAGS
% Create tags for writing data and error handling (all params_ variables)
try
cur_step = 'Generating output tags...';
cur_TP.update(cur_step);

% 6.1: Define additional parameters to save to Excel (ignore the warning, the variables are
% used)
params_heart_rate = calc_heart_rate(time_vec, params_perf_mode);
params_mask_org_path = mask_org_path;
params_input_conc = input_conc;
params_v1_idx = v1_idx;
params_v2_idx = v2_idx;
%fprintf(acq_path);
% [params_study_date, params_acq_label] = gen_study_info(acq_path);
% fprintf(params_acq_label);
tags = gen_tags_();
clc;

catch ME
    %delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end

% SECTION 7: POST-PROCESSING
% 7.1:  Post process whole-organ perfusion map, if specified
try
cur_step = 'Post-processing perfusion map...';
cur_TP.update(cur_step);

if (params_filt_size_mm > 0) && ~isempty(params_filt_type)
    cur_step = strrep(cur_step,'...', ' | Filtering whole organ perfusion map...');
    cur_TP.update(cur_step);
    filter_map_info = struct;
    filter_map_info.filt_size_mm = params_filt_size_mm;
    filter_map_info.filt_type = params_filt_type;
    filter_map_info.v1_idx = v1_idx;
    filter_map_info.v2_idx = v2_idx;
    filter_map_info.input_conc = input_conc;
    filter_map_info.delta_time = delta_time;
    filter_map_info.acq_path = acq_path;
    filter_map_info.mask_org_path = mask_org_path;
    filter_map_info.vx_size = params_vx_size;
    filter_map_info.ID = tags.ID;
    
    [perf, perf_maps] = filter_organ_perfusion(perf, perf_maps, organ_mask, params_vx_size, params_filt_size_mm, params_filt_type, filter_map_info);
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end

% SECTION 8: CALCULATE REGIONAL PERFUSION
try
cur_step = 'Calculating regional perfusion...';
cur_TP.update(cur_step);

if ischar(params_xlsx_path) && (ischar(params_mask_reg_path) && length(params_mask_reg_labels) > 1)
    params_mask_reg_path = verify_path(acq_path, params_mask_reg_path, 'RegionalMask');
    regional_mask = load_volume(params_mask_reg_path); % Correct, use on all other computers
    [perf, perf_maps, mass, change_hu] = calc_regional_perfusion(perf, perf_maps, mass, change_hu, v1_vol, v2_vol,...
                                                        organ_mask, regional_mask, params_mask_reg_labels,...
                                                        params_tissue_rho, params_vx_size );
    cur_step = strrep(cur_step, '...', ' | Regional perfusion determined...');
    cur_TP.update(cur_step);
else
    cur_step = strrep(cur_step, '...', ' | Regional perfusion not specified...');
    cur_TP.update(cur_step);
end
 
catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        rethrow(ME);
    else
        return
    end
end
clc;
% SECTION 9: SAVE DATA TO XLSX FILE
try
cur_step = 'Saving results...';
cur_TP.update(cur_step);

if ischar(params_xlsx_path)
    cur_step = strrep(cur_step, '...', ' | Writing results to Excel file...');
    cur_TP.update(cur_step);
    save_perf_(params_xlsx_path, 'Whole_Organ', tags, 'Whole_Organ', perf.whole_organ, delta_time, mass.whole_organ, change_hu.whole_organ, params_xlsx_add_col);
    save_params_(params_xlsx_path, tags);
    if ischar(params_mask_reg_path) && length(params_mask_reg_labels) > 1
        % LOAD REFERENCE IF PROVIDED
        if ~isempty(perf_ref)
            for i = 2 : length(params_mask_reg_labels)
                if ~isfield(perf, params_mask_reg_labels{i}) || ~any(ismember(perf_ref(:,1), params_mask_reg_labels{i}))
                    continue
                end
                cur_perf = perf.(params_mask_reg_labels{i});
                cur_perf(3) = perf_ref{ismember(perf_ref(:,1), params_mask_reg_labels{i}), 3};
                perf.(params_mask_reg_labels{i}) = cur_perf;
            end
        end
        % WRITE TO EXCEL
        save_perf_regional_(params_xlsx_path, tags, params_mask_reg_labels, perf, delta_time, mass, change_hu, params_xlsx_add_col);
    end
    params_reg_groups = {'SUP', '(ANTSUP)|(POSTSUP)|(SUPERIOR)';...
                         'INF', '(ANTINF)|(POSTINF)|(INFERIOR)'};
    if ischar(params_mask_reg_path) && ~isempty(params_reg_groups)
        if ~isempty(perf_ref)
            for i = 1 : length(params_reg_groups)
                cur_regexp = params_reg_groups{i, 2};
                cur_group = params_reg_groups{i, 1};
                cur_regions = fieldnames(perf);
                cur_group_fields = cur_regions(~cellfun('isempty', regexp(cur_regions, cur_regexp)));
                cur_perf = [0 0 0];
                mean_c = 0;
                for j = 1 : length(cur_group_fields)
                    temp_perf = perf.(cur_group_fields{j});
                    if any(isnan(temp_perf))
                        continue
                    end
                    cur_perf = cur_perf + temp_perf;
                    mean_c = mean_c + 1;
                end
                cur_perf = cur_perf ./ mean_c;
                perf.(cur_group) = cur_perf;
                mass.(cur_group) = 'N/A';
                change_hu.(cur_group) = 'N/A';
            end
            save_perf_regional_(params_xlsx_path, tags, {'GROUP_PLUGS', 'SUP', 'INF'}, perf, delta_time, mass, change_hu, params_xlsx_add_col);
        end
        
    end
end
clc;
if ischar(params_xlsx_main_path)
    cur_step = strrep(cur_step, '...', ' | Writing results to main Excel file...');
    cur_TP.update(cur_step);
    save_perf_(params_xlsx_main_path, 'Whole_Organ', tags, 'Whole_Organ', perf.whole_organ, delta_time, mass.whole_organ, change_hu.whole_organ, {});
    save_params_(params_xlsx_main_path, tags);
    if ischar(params_mask_reg_path) && length(params_mask_reg_labels) > 1
        save_perf_regional_(params_xlsx_main_path, tags, params_mask_reg_labels, perf, delta_time, mass, change_hu, {});
    end
end

catch ME
    delete(cur_TP, [cur_step 'ERROR\n']);
    if ~params_safe_mode
        throw(ME);
    else
        return
    end
end


% SECTION 10: UPDATE STATUS
% display_prog_(cur_TP, tags, perf.whole_organ, 'COMPLETED');



%% HELPER FUNCTIONS (ALPHABETIZED):end
    function [ ] = check_params_(usr_params_, str_prefix_tag_)
        allowable_params = who('-regexp', ['^' str_prefix_tag_]);
        def_usr_vars = fieldnames(usr_params_);
        for i_ = 1 : length(def_usr_vars)
            cur_var = def_usr_vars{i_};
            if ~any(strcmp([str_prefix_tag_ cur_var], allowable_params))
                warning('MolloiWarning:inputParams:parameterNotAllowed',...
                    'MolloiWarning \nInputParams | INPUTTED PARAMETER NOT READ | %s | Please double-check the inputted parameters\n',...
                    cur_var);
            end
        end
    end

    function [ ] = display_prog_(TP_, tags_, perf_, status_)
%         str_form = '%s | %s | %s | %13s | %2.2f %s %2.2f mL/min/g | %s\n';
        str_form = '%s | %s | %s | %2.2f %s %2.2f mL/min/g | %s\n';
%         sprintf(str_form, tags_.ID, tags_.study_date, tags_.acq_label, tags_.perf_mode, perf_(1), char(177), perf_(2), status_);
%         delete(TP_);

%         delete(TP_, sprintf(str_form, tags_.ID, tags_.study_date, tags_.acq_label, tags_.perf_mode, perf_(1), char(177), perf_(2), status_));
        delete(TP_, sprintf(str_form, tags_.ID, tags_.study_date, tags_.perf_mode, perf_(1), char(177), perf_(2), status_));
    end

    function [organ_mode_] = get_organ_mode_(acq_path_)
        % TRY TO GUESS WHICH ORGAN IS BEING PROCESSED
        % ORIENTATION OF VOLUMES IS DIFFERENT IF ORGAN FROM A
        % CARDIAC(HEART) DATASET
        %
        % POSSIBILITIES:
        %   'HEART'
        %   'LUNG'
        %   'BRAIN'
        %   'KIDNEY'
        
        keyword_map = containers.Map;
        keyword_map('HEART') = {'HEART', 'CARDIAC'};
        keyword_map('LUNG') = {'LUNG', 'PULMONARY'};
        keyword_map('BRAIN') = {'BRAIN', 'CEREBRAL'};
        keyword_map('KIDNEY') = {'KIDNEY', 'RENAL'};
        
        organ_keys = keyword_map.keys;
        organ_mode_ = 'HEART'; % BY DEFAULT...
        for key_ = organ_keys
            for kword_ = keyword_map(key_{1})
                if strfind(lower(acq_path_), lower(kword_{1}))
                    organ_mode_ = key_{1};
                    return
                end
            end
        end
        
    end

    function [tags_] = gen_tags_( )
        % This function creates a struct (tags_) that will be used
        % throughout the function to help save the parameters used.
        % Specifically, all variables whose name starts with 'params_' will
        % be added to tags_.  Additionally, the full file path to this
        % function will be added to tags_.  Finally, (and most
        % importantly) an UNIQUE ID will be created, based of the time the
        % function is ran.  This ID field will be used to save perfusion
        % and parameter data to Excel.  Think of tags_ as a DICOM header.
        cur_datetime = round(clock);
        ID  = sprintf('%04i%02i%02i%02i%02i%02i', cur_datetime(1),... % Year (YYYY)
                                                  cur_datetime(2),... % Month (MM)
                                                  cur_datetime(3),... % Day (DD)
                                                  cur_datetime(4),... % Hour (HH)
                                                  cur_datetime(5),... % Minute (MM)
                                                  cur_datetime(6));   % Second (SS)
        cur_vars = who('-regexp', '^params_');
        tags_.function_name = mfilename('fullpath');
        tags_.ID = ID;
        for var = cur_vars'
            % Add all variables that start with 'params_' to tags_
            t_var = strrep(var, 'params_',''); 
            % IGNORE FOLLOING PARAMS FOR REPORTING
            if any(strcmp(t_var{1}, {'aux_aif_vec', 'aif_vec', 'vol_idx', 'mask_reg_labels', 'xlsx_add_col','reg_groups'}))
                continue
            end
            if size(size(eval(var{1})),2) == 1 ||...
                ischar(eval(var{1})) || isscalar(eval(var{1}))
                tags_.(t_var{1}) = eval(var{1});
            elseif size(eval(var{1}), 3) > 1
                tags_.(t_var{1}) = eval(['mean(' var{1} '(:))']);
            elseif size(eval(var{1}), 2) > 1
                tags_.(t_var{1}) = sprintf('%0.2f ', eval([var{1} '(:)']));
            else
                tags_.(t_var{1}) = 'N/A';
            end 
        end
    end
  
    function [ ] = save_perf_(xlsx_path_, sheet_, tags_, region_, perf_, delta_time_, mass_, delta_hu_, xlsx_add_col_)
        % Save perfusion data to Excel file.  Further outputs can be added
        % through this function.  Be sure to reflect changes in save_perf_
        % in save_perf_regional_!
        if mass_ == 0
            return
        end
        XLSX_struct = struct;
        
        % Enter data into struct
        XLSX_struct.ID              = tags_.ID;
%         XLSX_struct.StudyDate       = tags_.study_date;
        XLSX_struct.StudyDate       = 'N/A';
        XLSX_struct.Acquisition     = 'N/A';
        XLSX_struct.PerfMode        = tags_.perf_mode;
        XLSX_struct.Region          = region_;
        XLSX_struct.Perfusion       = perf_(1);
        XLSX_struct.Perfusion_STD   = perf_(2);
        if length(perf_) == 3
            XLSX_struct.Perfusion_REF = perf_(3);
        end
        XLSX_struct.Flow            = perf_(1) * mass_;
        XLSX_struct.Flow_STD        = perf_(2) * mass_;
        XLSX_struct.DeltaTime       = delta_time_;
        XLSX_struct.Mass            = mass_;
        XLSX_struct.DeltaHU         = delta_hu_;
        XLSX_struct.HeartRate       = tags_.heart_rate;
        if ~isempty(xlsx_add_col_)
            for i_ = 1 : size(xlsx_add_col_, 2)
                cur_add_col = xlsx_add_col_{i_};
                XLSX_struct.(cur_add_col{1}) = cur_add_col{2};
            end
        end
        
        
        % ADD FURTHER OUTPUTS HERE
        
        % Save data to EXCEL
        WriteStructExcel(xlsx_path_, sheet_, XLSX_struct);
    end

    function [ ] = save_perf_regional_(xlsx_path_, tags_, regional_labels_, perf_, delta_time_, mass_, hu_change_, xlsx_add_col_)
        % Save regional perfusion to Excel file
        EXCLUSION_REGIONS = {'IGNORE'};
        for i_ = 2 : length(regional_labels_)
            label = regional_labels_{i_};
            if any(strcmp(label, EXCLUSION_REGIONS))
                continue
            end
            save_perf_(xlsx_path_, regional_labels_{1}, tags_, label, perf_.(label), delta_time_, mass_.(label), hu_change_.(label), xlsx_add_col_);
        end
    end

    function [ ] = save_params_(xlsx_path_, tags_)
        WriteStructExcel(xlsx_path_, 'PARAMS', tags_);
    end
    
    function [ ] = toggle_warnings_(of_)
        warning(of_, 'MolloiWarning:perfusionMode:Retrospective');
        warning(of_, 'MolloiWarning:perfusionMode:Prospective');
        warning(of_, 'MolloiWarning:volumeSelection:autoPeak');
        warning(of_, 'MolloiWarning:volumeSelection:fixedDelay');
        warning(of_, 'MolloiWarning:Registration:statusRegistration');
        warning(of_, 'MolloiWarning:FileIO:genMAT');
        warning(of_, 'MolloiWarning:FileIO:fileNotFound');
        warning(of_, 'MolloiWarning:FileIO:loadingMAT');
        warning(of_, 'MolloiWarning:FileIO:loadingDCM');
        warning(of_, 'MolloiWarning:FileIO:localPath');
        warning(of_, 'MolloiWarning:FileIO:absolutePath');
    end

end
